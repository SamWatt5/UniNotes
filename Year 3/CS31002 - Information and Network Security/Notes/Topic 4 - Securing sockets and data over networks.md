You have seen previously how sockets provide facilities for transmitting data between computers through networks, and how that data can be spied on during transit eventually. There are many ways to secure data over networks, the most trivial being to encrypt it long before even entering the realm of networks. However, this is not the case most of the time, creating a need for networks to integrate solution that can assist with information security, preferably without interfering with existing network facilities such as sockets. Fortunately, the layering principle of networks provide the framework to facilitate this by adding a layer of encrypting the data before transmission (and the opposite at reception). The first protocal created for this was Secure Sockets Layer (SSL), which after many updates and some renaming became Transport Layer Security (TLS).
## SSL and TLS
Inside the operating system, sockets are an interface to the network hardware (in some systems, particularly embedded ones, the transport layer is implemented in the hardware too, not even by the OS) for processes which are running end-user applications. Any mechanism to protect the data needs to be inserted in-between the process holding the data, which corresponds to the application layer, and the socket API, which corresponds to the transport layer. The approach taken by SSL/TLS is to create a wrapper to regular socket calls from the OS API, providing similar calls which will implement the encryption/authentication above normal sockets with minimal adaption required in applications. SSL/TLS assumes exchanging an unprotected low of data with the process, and having below it a reliable flow of data from the OS which needs confidentiality, authenticity and integrity added. We will learn about how it does so later in the module, for now we can consider this as a black-box layer. The only thing we need to know for now is that it requires digital certificates.
