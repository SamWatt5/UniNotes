# Clean Code
- A philosophy in software engineering that prioritizes **human readability** and **ease of change**.
- Often with simple common-sense practices:
	- Clear intent
	- Meaningful naming of fields, variables, functions, etc.
	- Cohesion: functions or objects that focus on doing one thing well
	- Avoid duplication
	- Avoiding hard-coded values in code
	- Self-documenting code (versus out-of-date comments / documentation)
	- Consistency in style, layout, format and structure
	- Application of core software engineering principles: DRY, KISS, etc.
# Principles of Clean Code
- **K**eep **I**t **S**imple, **S**tupid (KISS): focus on simplicity rather than "cleverness". Why overcomplicate the code for someone in the future?
- **D**on't **R**epeat **Y**ourself (DRY): avoid duplication and repetition, otherwise you increase effort as well as the risk of inconsistencies and errors
- **Y**ou **A**ren't **G**oing to **N**eed **I**t (YAGNI): Don't over-engineer code now for things that may not exist in the future
- The "Boy Scout" Rule: Leave the code cleaner than you found it - small continuous improvements that prevent technical debt from growing
- Refactor continuously
- The law of Demeter (LoD) or Principle of Least Knowledge: Only "talk" to your immediate frineds, e.g. avoid long, chaining
- SOLID principles
## Clean Code Principles
### Meaningful names
Bad:
```python
def calc(a,b):
	return a * 0.2 + b
```
 Good:
```python
def calculate_total_price(base_price, tax_rate):
return base_price * tax_rate + base_price
```
### Smaller, more focused functions
Bad:
```python
def process_order(order):
	# validate
	if not order.items:
		raise ValueError("Empty")
	# calculate total
	total = sum(i.price for i in order.items)
	# send email
	print("Email sent")
	return total
```
Good:
```python
def validate(order):
	if not order.items:
		raise ValueError("Order has no items")

def calculate_total(order):
	return sum(i.price for i in order.items)
	
def send_conformation email(order):
	print("Email send")
	
def process_order(order):
	validate(order)
	total = calculate_total(order)
	send_conformation_email(order)
	return total
```
### Keep It Simple, Stupid (KISS)
Using "clever" features that are hard to read or maintain
Bad:
```python
# A nested list comprehension that might be harder to comprehend or debug
def get_adult_emails(users):
	return [u.email for u in users if (lambda x: x.age >= 18)(u) and u.active]
```
Good:
```python
def get_adult_emails(users):
	emails = []
	for user in users:
		if user.age >= 18 and user.active:
		emails append(user.email)
	return emails
```
- Could the top/former be better for performance? Maybe. but is it "YAGNI" until we know otherwise?
### Don't Repeat Yourself (DRY)
Avoid duplication and repetition, otherwise you increase effort as well as the risk of inconsistencies and errors. Avoid "Magic" values too
Bad:
```python
def calculate_apple_price(count):
	return (count * 1.0) * 1.05 # count * price + 5% tax
	
def calculate_banana_price(count):
	return (count * 0.5) * 1.05 # count * price + 5% tax
```
Good:
```python
TAX_RATE = 1.05

def apply_tax(amount)
	return amount * TAX_RATE

def calculate_price(count, unit_price)
	return apply_tax(count * unit_price)
```
### You Aren't Going to Need it (YAGNI)
Building features for "future" requirements that don't exist yet: "Speculative" engineering or over-engineering.
Guesstimating future requirements:
```JS
// get the price of coffee
function getCoffeePrice(basePrice, discountCode, currencyType, loyaltyPoint) {
	// We don't support discounts or loyalties yet
	return 5.00;
}
```
Versus what we know now:
```JS
function getCoffeePrice() {
	return 5.00;
}
```
### Law of Demeter
Talk only to your immediate friends. More specifically, avoid long chains of method calls: `a.getB().getC().doSomething().doSomething();`
Bad:
```Java
class OrderService {
	void processOrder(Order order) {
		// Long chains of calls - Order -> Customer -> Address
		String city = order.getCustomer().getAddress().getCity();
		System.out.println("Shipping to " + city);
	}
}
```
Good:
```Java
class Customer {
	private Address address;
	
	String getShippingCity() {
		return address.getCity();
	}
}

class Order {
	private Customer customer;
	
	String getShippingCity() {
		return customer.getShippingCity;
	}
}

class OrderService {
	void processOrder(Order order) {
		// Only talk to Order - its direct friend
		String city = order..getShippingCity();
		System.out.println("Shipping to " + city);
	}
}
```
### SOLID Principles
#### **S**ingle Responsibility Principle: 
Objects or functions should have a singular focus, a single reason to change
- A class with many responsibilities:
```python
class User:
	def save_to_db(self): ...
	def calculate_tax(self): ...
	def generate_pdf_report(self): ...
```
- Refactored into separate, more singularly-focused classes
```python
class DataStore: # Handles Data storage
	def save(self, user): ...
	
class TaxCalculator: # Handles tax
	def calculate(self, user): ...
	
class ReportGenerator: # Handles report generation
	def to_pdf(self, data): ...
```
#### **O**pen-Closed Principle: 
Objects or functions should be open for extension (new functionality), but closed to modification
- Tell-tale signs: checking types of objects/variables to know what to do with them
```python
def draw_shape(shape):
	if shape.type == "circle":
		draw_circle()
	elif shape.type == "square":
		draw_square()
```
- Use polymorphism instead:
```python
class Shape:
	def draw(self):
	
class Circle(Shape): # inherit from shape
	def draw(self): # override
		# draw circle
		
def render(shape: Shape):
	shape.draw() # Could be any shape
```
#### **L**iskov Substitution Principle: 
Child classes should conform to the expected behaviour of their parent
Or: child classes shouldn't be inheriting thigns they don't need from their parent, or having to ignore, circumvent, or undo things being inherited from their parent
- Bad:
```python
class Bird:
	def fly(self): ...
	def eat(self): ...
	
class Penguin(Bird):
	def fly(self):
		raise Exception("Penguins can't fly")
```
- Good:
```python
class Bird:
	pass

class FlyingBird(Bird):
	def fly(self):...

class Penguin(Bird):
	pass
```
#### **I**nterface Segregation Principle: 
Interfaces should be singularly-focused too, i.e. each interface should serve the needs of a single "client"
Does your class or interface have functions that are relevant only to specific "clients" that make use of it?
- Bad:
```python
class Worker:
	def work(self): ...
	def eat(self): ...
```
- Good:
```python
class Workable:
	def work(self): ...
	
class Eatable:
	def eat(self): ...

class Human(Workable, Eatable):
	# implement human aspects
	
class Robot(Workable):
	# implement robot aspects
```
#### **D**ependency Inversion Principle: 
- High-level "modules" should not have a direct dependency on low-level modules. Both should depend on **abstractions** (e.g. interfaces).
- Below, NotificationService has a direct/tight coupling on a specific type of Sender
```C#
public class EmailSender
{
	public void Send(string message)
	{
		Console.WriteLine("Sending Email: " + message);
	}
}

public class NotificationService
{
	private readonly EmailSender _emailSender = new EmailSender();
	
	public void Notify(string message)
	{
		_emailSender.Send(message);
	}
}
```
To fix this we can:
- Define an abstract sender:
```C#
public interface IMessageSender
{
	void Send(string message);
}
```
- That other senders derive from:
```C#
public class EmailSender : IMessageSender
{
	public void Send(string message)
	{
		Console.WriteLine("Sending EMAIL: " + message);
	}
}

public class SmsSender : IMessageSender
{
	public void Send(string message)
	{
		COnsole.WriteLine("Sending SMS: " + message)
	}
}
```
- Notification Service depends on the interface/abstraction, not the "lower level" module
```C#
public class NotificationService
{
	private readonly IMessageSender _sender;
	
	public NotificationService(ImessageSender sender)
	{
		_sender = sender;
	}
	
	public void Notify(string message)
	{
		_sender.Send(message);
	}
}

NotifcationService service = new NotificationService(new SmsSender());
service.Notify("Hello!");
```

