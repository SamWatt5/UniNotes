## Tight Couplers
### Feature Envy
- This is where a method in one class seems more interested in the data or behaviour of another class than the one it actually "lives" in, ususally indicated where it seems to spend most of its time accessing data or calling getter methods on other classes to get its work done
- Example below shows a PriceCalculator method that is "obsessed" with a Customer's data
```Java
class Customer() {
	Address address;
	int orderNum;
	int type;
}

class PriceCalculator() {
	double getCustomerDiscount(customer) {
		if (customer.address.state == "NY"
		and customer.orderNum > 10
		and customer.type == "Premium"){
			return 0.15;
		else {
			return 0.05;
		}
		}
	}
}
```
- Problem: Tighter coupling between classes
- Solution: Instead of asking an object for its data to make a decision, *tell* the object what you want it to do and let it use its own data to do it.
- *Refactoring Option:* Use **Move Method** to move the envious method (or the part of it that is envious) into the class it is interested in
```Java
class Customer() {
	Address address;
	int orderNum;
	int type;
	
	double getDiscount() {
		if (address.state == "NY"
		and orderNum > 10
		and type == "Premium"){
			return 0.15;
		else {
			return 0.05;
		}
		}
	}
}

class PriceCalculator() {
	double getTotal(customer){
		if (total = customer.getDiscount() + ...)
	}
}
```
### Inappropriate Intimacy
- Related to Feature Envy
- When two classes know *too much* about each other's internal details and they become overly dependent / coupled on how each other works
- Signs of this occuring:
	- They rely on each other's internal structure, e.g. knowing too much about how one class likes to structure its logic
	- They break encapsulation to "peek" inside each other, e.g. having access to certain fields that should be private
	- They call many low-level methods on each other instead of more coarse-grained requests
- *Refactoring Option:* Use **Move Method** to move behaviour into the class that owns the behaviour or **Hide Delegate** if Class A is reaching through Class B in order to get to Class C
### Message Chains
- When a piece of code has to navigate through a long chain of objects or methods to get what it needs ( see also [[1.2 - Principles of Clean Code#Law of Demeter|Law of Demeter]])
- `employee.get_department().get_manager().get_email()`
	- Employee -> Department -> Manager
- Problems:
	- Makes the system fragile - if any link in the chain changes, many places break
	- Forces the client to understand internal object relationships
	- Often leads to Inappropriate Intimacy or Feature Envy
- *Refactoring Option:* Use **Hide Delegate**, i.e. add a method to the first object in the chain so the client doesn't need to dig through the chain itself:
	- `eployee.get_manager_email()`
#### Digressing - There are Trade Offs to be Made
- Does the following not add extra responsibility to the Employee class, therefore (slightly) damaging its cohesion?:`employee.get_manager_email()`
- *yes*, but we need to make trade-offs. This isn't desirable:`employee.get_department().get_manager().get_email()`
- The following alternative exposes the client/caller to additional detail/coupling too, risking inappropriate intimacy:
```Java
Department d = employee.getDepartment()l
Manager m = d.getManager();
String email = m.getEmail();
```
