# What is a "Design Pattern"?
- Design Patterns are general, reusable solutions to common problems in software design, reflecting experience-based best practices.
- Basically, other people have been there, done that before you, identified recurring design issues, solved them, and encapsulated solutions as reusable templates
- The design patterns don't give you ready-made code, they give you a conceptual blueprint to work from.
## Why Design Patterns?
- They provide general, reusable solutions to known problems - avoiding you re-inventing the wheel
- They focus on code quality (e.g. flexibility, extensibility, maintainability), and they encapsulate principles of code quality (e.g. SOLID, etc.)
- They can aid communication and teamwork - a common vocabulary, shared names to common solutions
- However: be mindful of *over-engineering*, e.g. producing overly complex solutions to what was a simple problem.
## Categories of Design Patterns
Design Patterns fall into different categories depending on the nature of the task
### Creational Patterns
Focus on how objects are created, promoting loose coupling at the point of creation.
- Examples: *Factory Method*, *Builder*, *Singleton*
### Structural Patterns
Focus on how objects are composed and connected to form larger structures, ensuring loose coupling with respect to change
- Examples: *Decorator*, *Adapter*
### Behavioural Patterns
Focus on communication between objects
- Examples: *Strategy*, *Observer*, *Template Method*
# The "Strategy" Design Pattern
- The strategy pattern is used to "define a 'family' of algorithms, put each of them into a separate class, and make them interchangeable"
- Why? To avoid Code Smells that relate to type-checking (such as Switch Statements) and poor cohesion (such as Large Class, Long Method, Divergent Change), and violations of SOLID Principles such as SRP, OCP, DIP.
## Example: 
A navigation app that calculates routes for cars, walking, and cycling. Navigation by public transport is added later too.
### Original Design
```Java
public class NavigationApp {
	public void calculateRoute(source, destination) {
		if (navType == "car") {
			// lots of lines of code here to
			// handle this type of nav
		}
		else if (navType == "walk") {
			// lots of lines of code here to
			// handle this type of nav
		}
		else if (navType == "cycle") {
			// lots of lines of code here to
			// handle this type of nav
		}
	}
}
```
- Divergent Change / Single Responsibility issues
- Open but not closed to new navigation methods (e.g. public transport)
- Smell: Switch Statements
### Updated Design
- Define a parent interface and child implementations
```Java
// generic, parent version of algorithm / strategy
public interface  RouteCalculator {
	public void calculateRoute(source, destination);
}

// child classes inherit and implement the required methods from the parent interface
public class CarRouteCalculator implements RouteCalculator {
	@Override
	public void calculateRoute(source, destination) {
		// Lines of code here for car route planning
	}
}

public class WalkingRouteCalculator implements RouteCalculator {
	@Override
	public void calculateRoute(source, destination) {
		// Lines of code here for walking route planning
	}
}

public class CyclingRouteCalculator implements RouteCalculator {
	@Override
	public void calculateRoute(source, destination) {
		// Lines of code here for cycling route planning
	}
}
```
- Integrate this structure into the original code
```Java
public class NavigationApp {
	private RouteCalculator myRouteCalculator;
	
	public void setRouteCalculator(RouteCalculator rc) {
		myRouteCalculator = rc;
	}
	
	public void calculateRoute(src, dest) {
		myRouteCalculator.calculateRoute(src, dest);
	}
}
```
- Use the new family of algorithms
```Java
// Create the navigation app
NavigationApp app = new NavigationApp();

// Give it a route calculator to use
CarRouteCalculator crc = new CarRouteCalculator();
app.setRouteCalculator(crc);
app.calculateRoute(src, dest);

// Give it a different route calculator to use
WalkingRouteCalculator wrc = new WalkingRouteCalculator();
app.setRouteCalculator(wrc);
app.calculateRoute(src, dest);

// Any new type of route calculator in the future
PublicTransportRouteCalculator ptrc = new PublicTransportRouteCalculator();
app.setRouteCalculator(ptrc);
app.calculateRoute(src, dest);
```
### Benefits
- Route calculation strategies become swappable for each other
- We can easily add new route calculation strategies in the future (or remove existing strategies) with no impact on each other or the NavigationApp class
- We can easily modify existing strategies with no impact on each other or the NavigationApp class
- We are no longor harburing code sells - benefits future maintenance