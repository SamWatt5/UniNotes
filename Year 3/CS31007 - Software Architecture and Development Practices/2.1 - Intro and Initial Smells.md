# What is a "Code Smell"?
- When there's something "off" about your code, it doesn't "smell" right
- The code may work, but something instinctual is telling you that there's something about it that could be improved. Otherwise, it will be difficult to change, test, or understand in the future
- This could be a trigger for refactoring, e.g. to "clean" the code before it turns into technical debt.
## Common Code Smells
- Bloaters: code, methods, or classes are growing too large to handle
- Object-Oriented Abusers: Misuse of OOP principles
- Couplers: Excessive interdependence between objects and functions
- Dispensables: Pointing to unnecessary, redundant, or poorly written code
- Change preventers: making the code hard to modify in the future
- More generally, issues related to code that is hard to read or understand, or maintain:
	- Duplication and repetition in code
	- Large or complex structures
	- Tight coupling
	- Poor naming and structure
	- Unnecessary indirection or over-engineering
# Refactoring Code Smells
- Refactoring is the process of improving the internal strucutre of existing code without changing its external behaviour
- You aren't adding new features to the code, you are improving the existing code to make it cleaner
- Refactoring can be used to address code smells
## Common Refactorings
- **Extract Method:** E.g. where a method has become overlong and bloated and can be split into smaller methods OR just a block of code that has a clear purpose of its own
- **Rename Variable / Method / Class:** Easy win. Good naming is half the battle when it comes to clean code, to remove ambiguity, aid comprehension, and aid maintenance.
- **Extract Class:** When a single class is doing too much and can be divided into two or more smaller classes
- **Move Method / Field:** When a behaviour or data is in the wrong place - see examples later of Feature Envy or Inappropriate Intimacy
- **Replace Magic Number with Constant:** Self-explanatory. Literal, hard-coded values in code are prone to change and often scattered around multiple locations.
- **Replace Conditional with Polymorphism:** Don't check types. Push type-specific logic into dedicated objects.
- Introduce a **Parameter Object:** When the same, long list of parameters is being passed into multiple methods.
- **Pull Up Method / Field:** When child classes share a feature that can be brought up into the parent instead of duplicated across the children.
- **Encapsulate Field:** To turn public fields into get/set methods or properties.
## Bloaters
### Long Method
- Long method: E.g. a function that is > 100 lines long and handles too wide a range of functionality (see [[1.2 - Principles of Clean Code#**S**ingle Responsibility Principle|Single Responsibility Principle]])
```JS
function processOrder(order) {
	// 50 lines of validation logic...
	// 50 lines of database insertion logic...
	// 50 lines of email notification logic...
	// 50 lines of logging...
}
```
- *Refactoring Option:* Use **Extract Method** to break this into a collection of smaller functions.
### Large Class
- Large Class: E.g. an object that knows too much and does too much (see [[1.2 - Principles of Clean Code#**S**ingle Responsibility Principle|Single Responsibility Principle]])
```python
def ApplicationManager:
	def handle_users(self):...
	def handle_payments(self):...
	def handle_inventory(self):...
	def handle_notifications(self):...
```
- *Refactoring Option:* Use **Extract Class** - identify subsets of related methods and fields and extract them into a (set of) new, more focused class(es)
### Data Clumps
- Data Clumps: when the same set of variables or parameters are being used over and over again, e.g. as inputs into different methods
```python
def send_main(to, cc, bcc, msg):
def save_main(to, cc, bcc, msg):
def forward_mail(to, cc, bcc, msg):
```
- A potential cause of Shotgun Surgery (changes in many places)
- *Refactoring Option:* use a **Parameter Object** to encapsulate the shared parameters and pass an object instead
```python
def send_mail(emailObj):
def save_mail(emailObj):
def forward_mail(emailObj):
```
### Primitive Obsession
- Primitive Obsession: an obsession with using primitive types (int, String) for concepts such as a post code, phone number, even student ID, making them lack enforcement of validation rules and the code less expressive
```Java
String student_ID = "blah blah";
String post_code = "23 Main St, XYZ";
String student_id = "UOD_123456";
String student_id = "UUD_284453";
```
- *Refactoring Option:* Use **Replace Data Value With Object** to turn a primitive (e.g. String for a phone number) into its own class
### Long Parameter List
- Long Parameter List: a method or function that takes too many parameters
- Problems:
	- Hard to tell what the multiple values might be: `doTask(true, false, true, 10, 20)`
	- Fragile design: Updating the parameters and everywhere the function is called
	- Testing issues: you need to test different values for every input
- Different refactorings may be possible
- *Refactoring Option #1:* Use a **Parameter Object** to encapsulate the parameters into an object as an input instead
- *Refactoring Option #2:* Replace with a **Method Object** - if the method is complex and with many parameters, does it deserve to be an object in its own right?
- Others...