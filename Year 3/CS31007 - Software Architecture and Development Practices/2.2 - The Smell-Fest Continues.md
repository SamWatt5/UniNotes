## Object-Orientation Abusers
### Switch Statements
- Switch statements or if statements that select behaviour based on type
	- Same statement appears in multiple locations in code
	- Adding a new type requires modifications in many locations
- *Refactoring Option:* Use **Replace Conditional with Polymorphism** to create a child class for each "case" in your statement
bad:
```python
def processShape(Shape s):
	if s.type == "Circle":
		processCircle(S)
	elif s.type == "Square":
		processSquare(s)
	Etc.
```
good:
```python
class Shape:
	def process()

class Circle(Shape):
	def process()
	
def processShape(Shape s):
	s.process()
```
### Refused Bequest
- A child class inherits features it doesn't need from its parent (see [[1.2 - Principles of Clean Code#**L**iskov Substitution Principle|Liskov Substitution Principle]])
- *Refactoring Option #1:* Use **Replace Inheritance with Delegation** e.g. Car *has an* Engine instead of Car *inherits from* Engine
- *Refactoring Option #2:* Use **Extract Superclass** e.g. Penguin inherits from Bird but doesn't need a "fly" method. Rethink superclass -Bird *and* FlyingBird
- *Refactoring Option #3:* Use **Push Down Method/Field** where fields or methods have been placed into the parent but can be moved down into the child classes where they are most relevant.
## Change Preventers
### Divergent Change
- You are making changes to the same class or function for many different reasons  (see [[1.2 - Principles of Clean Code#**S**ingle Responsibility Principle|Single Responsibility Principle]])
- E.g. updating a BankAccount class to modify cash withdrawal requirements, to modify statement printing requirements, to modify report generation requirements.
- Problems:
	- The class keeps growing
	- Every new feature touches this class
	- Different developers modify it for unrelated reasons
	- The class becomes fragile - a change in one area risks breaking another
- *Refactoring Option:* Use **Extract Class** to move each responsibility into its own class
### Shotgun Surgery
- When a single change in your requirements forces you to make many small changes across many different areas of your system
- Examples:
	- Hardcoded values throughout code
	- The impact of adding new fields or logic
```Java
class Order() {
	List<Items> items;
}

class UI() {
	void displayOrder(order) {
		for each item in order, get price
	}
}

class OrderReport() {
	void displaySummary(order) {
		for each item in order, get price, etc.
	}
}
```
Then make change to Order class, i.e. add a discount:
```Java
class Order() {
	List<Items> items;
	discount = 0.05;
}

class UI() {
	void displayOrder(order) {
		for each item in order, get price
		Incorporate discount into cost calculation
	}
}

class OrderReport() {
	void displaySummary(order) {
		for each item in order, get price, etc.
		Incorporate discount into cost calculation
	}
}
```
- *Refactoring Option:* Use **Move Method/Move Field** to move related behaviour into the class that owns the data
```Java
class Order() {
	List<Items> items;
	
	double getTotal() {
		for each item in order, get price
	}
}

class UI() {
	void displayOrder(order) {
		order.getTotal()
	}
}

class OrderReport() {
	void displaySummary(order) {
		order.getTotal()
	}
}
```