# Introduction
We will explore:
- Writing clean and maintainable code
- Identifying and refactoring code smells
- Applying common software design patterns
- Unit testing and Test-Driven Development (TDD)
- Conduction effective code reviews
- Version control best practices (e.g. Git branching strategies)
- Secure coding principles
- Defensive programming techniques
# Motivation: The cost of Software Maintenance
Numbers vary, but studies often show that maintenance activities will often dominate costs, effort, and resources for software development organisations
## Why is maintenance needed?
Software is not a static product, it is a "living" system. Maintenance is required for several reasons:
- **Bug Fixes**: Despite your best efforts, bugs are inevitable and need to be addressed
- **Market Relevance**: User expectations change. If you don't add the features people want, they will move to a competitor.
- **Compatibility**: New hardware (like faster chips) or software (like updated web browsers) can cause old code to break if not adapted.
- **Security**: As hackers discover new vulnerabilities, software must be patched to protect user data.
- **Efficiency**: Over time, code can become "messy" (code entropy). Maintenance helps clean this up so the software doesn't slow down.
## What type of maintenance is required?
- **Corrective**: Fixing bugs
- **Adaptive**: Updating software to accommodate changes in environment
- **Perfective**: Adding features requested by users to stay competitive
- **Preventive**: Future-proofing, refactoring, and "cleaning"
## What causes maintenance challenges?
- Developers (forced to) take "shortcuts" to meet a deadline
- Quick fixes
- Messy code
- Poor documentation
- Code complexity
- No unit tests
- Knowledge gaps when people leave
- Under resourced in favour of shiny new features
- The evolving landscape around us - updates, patches, new frameworks, disappearing frameworks, etc.
## Technical Debt
- Technical debt refers to the extra work and future costs created when you choose a quick, easy solution now over a ore robust longer-term solution.
- You end up paying large amounts of "interest" later for taking shortcuts now shortcuts that may increase maintenance, bugs, and rework later.
# Best Practices
- Write "Clean" and defensive code in the first, e.g. according to sound coding principles (DRY, KISS, SOLID, YAGNI)
- Automated Testing, e.g. through Unit Tests and Regression Testing (a suite of tests that is run every time a change is made to ensure that the new update didn't break old features)
- Refactoring: periodically cleaning up code without changing its external behaviour.
- Documentation-as-Code: keeping documentation inside the code where it has more chance of being kept up to date
- Tooling support: E.g. tools to:
	- Enforce coding standards and quality (such as code stylers, linters)
	- Tools to aid code understanding, e.g. reverse engineering
	- Tools that support effective teamwork, communication, and collaboration, including effective version control
- 