- Template Method allows you to define the *skeleton* of an algorithm in a base class while letting child classes fill in some of the details.
- Some steps are implemented by the base class itself (so they can be shared / inherited by the child classes)
- Other steps are left "abstract" or as hooks for child classes to inject their own details into
- Child classes can customise the parts of the algorithm that they need to, without changing the overall structure of the algorithm
## Example
```Java
public abstract class DataExporter {
	public abstract void export(data);
}

public class CSVExporter extends DataExporter {
	public void export(data) {
		connectToFileSystem();
		file = openOutputStream();
		
		// CSV-Specific Logic
		formatted_data = data + ',';
		file.write(formatted_data);
		
		logExportCompletion();
		closeOutputStream(file);
	}
}

public class JSONExporter extends DataExporter {
	public void export(data) {
		connectToFileSystem();
		file = openOutputStream();
		
		// JSON-Specific Logic
		formatted_data = {"data":};
		file.write(formatted_data);
		
		logExportCompletion();
		closeOutputStream(file);
	}
}
```
### Pull up main structure of algorithm into parent class
```Java
public abstract class DataExporter {
	public void export(data) {
		connectToFileSystem();
		file = openOutputStream();
		
		// ### Export Specific Logic
		// ### Needs To Go Here
		
		logExportCompletion();
		closeOutputStream(file);
	}
}
```
### Put in a "hook" for child classes to inherit and override
```Java
public abstract class DataExporter {
	public void export(data) {
		connectToFileSystem();
		file = openOutputStream();
		
		exportDataToFile(file, data);
		
		logExportCompletion();
		closeOutputStream(file);
	}
	
	public abstract void exportDataToFile(file, data);
}
```
### Child classes override the "hook" to inject their specific requirements
```Java
public class CSVExporter extends DataExporter {
	public void exportDataToFile(file, data) {
		// CSV-Specific Logic
		formatted_data = data + ',';
		file.write(formatted_data);
	}
}

public class JSONExporter extends DataExporter {
	public void exportDataToFile(file, data) {
		// JSON-Specific Logic
		formatted_data = {"data":};
		file.write(formatted_data);
	}
}
```
### Using the classes
```Java
CSVExporter csvExporter = new CSVExporter();
csvExporter.export(data); // <- Uses the CSV-Specific logic from above
```
## Benefits
- Avoid duplication of the same logic / steps / algorithm in the child classes
- Push as much of the behaviour as we can into a single location - the parent class
- Leave "hooks" for child classes to inject their own specific requirements