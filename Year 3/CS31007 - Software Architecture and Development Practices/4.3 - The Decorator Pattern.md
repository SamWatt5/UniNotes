- The Decorator pattern allows you to attach new responsibilities to objects by "wrapping" new behaviours around them
- It is an alternative to inheritance - instead of creating a child class to extend or add to the functionality of an object, you wrap it *inside* another object
- This can prevent an "explosion" of child classes for different combinations of behaviours
- E.g. Imagine a parent class Coffee, and then child classes for CoffeeWithMilk, CoffeeWithSugar, CoffeeWithMilkAndSugar, CoffeeWithHotWater, CoffeeWithHotWaterAndSugar, and so on
## Example: File Stream
- imagine you have a class to represent a file stream with methods to read() or write() a basic stream of characters to a file: `FileStream`
- You discover that you need more specific forms of this, e.g.
	- A `BufferedFileSystem` that incorporates buffering logic into the read() and write() methods
	- An `EncryptedFileStream` that incorporated encryption and decryption logic into the read() and write() methods
	- A `CompressedFileStream` that incorporates compression and decompression into the read() and write() methods
- But then you discover that these behaviours can be combined in various ways too, e.g. compression and encryption, compression and buffering, buffering and encryption, all three together
- We end up with more file classes: a `BufferedCompressedFileStream`, a `BufferedEncryptedFileStream`, a `CompressedEncryptedFileStream`, a `BufferedCompressedEncryptedFileStream`
- There's lots of repetition going on here, and what if new features came along in the future?
- Inheritance isn't working the way it should do here!!!
### Decorator: an alternative subclasses
Instead of inheriting new forms of file stream behaviour ![[Pasted image 20260209143931.png]] 
Let's Decorate objects with new behaviours, e.g. "wrap" them in additional behaviours![[Pasted image 20260209144008.png]]
### Building up the Decorator Structure
Create a parent interface that represents the fundamental behaviour we are trying to encapsulate, i.e. the generic idea of a FileStream that can read() and write()
```Java
public interface IFileStream {
	public Data read();
	public void write(Data d);
}
```
Create a child class to represent the basic, unadorned file stream
```Java
public class FileStream extends IFileStream {
	public Data read() { /* Core */ }
	public void write(Data d) { /* Core */ }
}
```
Create a child class to represent a file stream decorator
```Java
public class FileStreamDecorator implements IFileStream {
	IFileStream decoratedObj;
	public Data read();
	public void write(Data d);
}
```
Create specific forms of decorator as child decorator classes
```Java
public class EncryptionDecorator extends FileStreamDecorator {
	public Data read() {
		data = decoratedObj.read();
		// decrypt data and return it
	}
	
	public void write(Data d) {
		// encrypt data
		decoratedObj.write(data);
	}
}
```
### How this helps
- Create a basic file stream
```Java
FileStream fs = new FileStream();
```
- Create a decorator for encryption
```Java
EncryptionDecorator ed = new EncryptionDecorator();
ed.setDecoratedObject(fs);
```
- Pass the whole lot (represented by the outer object) somewhere else
```Java
otherFunctionInMyCode(ed);
```
### The "Other" function
```Java
public void otherFunctionInMyCode(IFileStream fs) {
	// uses read and write
	e.g. fs.write(data);
}

// In EncryptionDecorator:
public void write(Data d) {
	// encrypt data
	decoratedObj.write(data);
}

// In FileStream:
public void write(Data d) { /* core */}
```
### Multiple decorators can be use din whatever order is required
```Java
// create a basic file stream
FileStream fs = new FileStream();

// wrap a compression decorator around it
CompressionDecorator cd = new CompressionDecorator();
cd.setDecoratedObject(fs);

// wrap an encryption decorator around that
EncryptionDecorator ed = new EncryptionDecorator();
ed.setDecoratedObject(cd);

// call the method again
otherFunctionInMyCode(ed);
```
## Benefits
- Flexible, dynamic, runtime behaviour: You can wrap an objectwith any combination of decorators according to what you need in the moment
	- E.g. someone is saving a file to disk and they select "Encryption" from a checkbox, you simply add the required decorator as required
- We avoid the exponential explosion of child classes, creating a more resilient design
- It supports design principles such as SRP - each decorator focuses on a single responsibility
- It supports OCP - adding enw features (decorators) in the future without modifying existing code
- It may work with existing code, if it is already in a hierarchy.