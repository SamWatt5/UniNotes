# Revisiting our Factory
- Any problems here?
```Java
public class RouteCalculatorFactory {
	public static void RouteCalculator getRouteCalculator(String type) {
		if (type == "car") {
			return new CarRouteCalculator();
		}
		else if (type == "walk") {
			return new WalkRouteCalculator();
		}
		else if (type == "cycle") {
			return new CycleRouteCalculator();
		}
		// Etc.. more types now and/or in the future
	}
}
```
## The "if" Conundrum
- At some point, something in our code is going to have to create an instance of the specific type of object to use, and this will most likely require an "if" statement to determine its type - we can't eradicate this problem
- So, we have to put the "if" statement somewhere
- If we aren't happy with it in the RouteCalculatorFactory, put it somewhere else.
- Consider *dependency injection*
# The "Dependency Injection" Pattern
- Dependency injection is where an object receives its dependencies from an outside source rather than creating them from within itself
- In our example, instead of requiring the Navigation App to use a Factory to get the Route Calculator to use, we simply provide it directly to it and we prevent the Factory from doing it too
- Other classes in our design (such as a UI) can more happily absorb type-checking responsibilities
## Example
```Java
// In a UI class
public void onNavigate_btn() {
	// get the type of navigation to do, e.g. car, walking,
	String navType = navTypeDropdown.getSelectedItem();
	
	// get the type of route calculator to use for this
	RouteCalculator rc = null;
	if (navType == "car") { rc = new CarRouteCalculator(); }
	else if (navType == "walk") { rc = new WalkRouteCalculator(); }
	else if (navType == "cycle") { rc = new CycleRouteCalculator(); }
	
	// ask the Navigation App to plan the route, giving it the route
	// calculator to use
	NavigationApp na = new NavigationApp();
	na.calculateRoute(src,dest, rc); 
}
```
# Taking Factory Further: a "Factory Method"
- Factory method allows you to create an inheritance hierarchy of "creator" objects
- Parent class defines a general form of creator
- Child classes extend and support more specific forms of object creation
## Example
- When a (navigation) route is being calculated and displayed to users, the users can toggle between different types of overlay, e.g. Tourist Overlay, a Commuter Overlay. Each overlay uses different sets of symbols, icons, colour schemes, and other graphical elements.
### Map Overlays
```Java
// General / parent Map Overlay
public interface MapOverlay {
	public IconSet getIconSet();
	public ColourScheme getColourScheme();
}

// Child classes inherit and override map overlay methods
public class TouristMapOverlay implements MapOverlay {
	public IconSet getIconSet () { /* return tourist icon set */ }
	public ColourScheme getColourScheme() { /* return tourist colour scheme */ }
}

public class CommuterMapOverlay implements MapOverlay {
	public IconSet getIconSet () { /* return commuter icon set */ }
	public ColourScheme getColourScheme() { /* return commuter colour scheme */ }
}
```
### How are overlays created? A Factory?
```Java
public class MapOverlayFactory {
	public static void MapOverlay getMapOverlay(String type) {
		if (type == "tourist") {
			return new TouristMapOverlay();
		}
		else if (type == "commuter") {
			return new CommuterMapOverlay();
		}
		else if (type == "anOtherType") {
			return new AnOtherTypeOfMapOverlay();	
		}
		// Etc.. more types now and/or in the future
	}
}
```
### Alternative, use child classes to create specific types of overlay
```Java
// generic, parent version of route calculator
public abstract class RouteCalculator {
	public abstract MapOverlay getMapOverlay();
	
	public void calculateRoute(source, destination) {
		MapOverlay mo = getMapOverlay();
		// apply overlay to map, do route calculation, display route, etc.
	}
}

// child classes provie the relevant map overlay required
public class CommuterRouteCalculator extends RouteCalculator {
	@Override
	public MapOverlay getMapOverlay() { return new CommuterMapOverlay(); }
}

public class TouristRouteCalculator extends RouteCalculator {
	@Override
	Public MapOverlay getMapOverlay() { return new TouristMapOverlay(); }
}
```
### Usage
```Java
CommuterRouteCalculator crc = new CommuterRouteCalculator();
crc.calculateRoute(src, dest);
```
## Beware: "Designatio sui causa" - Design for its own sake
- When people discover design patterns, they can mistakenly think they must use them all the time, as much as possible
- This potentially falls into traps such as KISS, YAGNI, Speculative Generality
- Make sure you are using design patterns to solve real problems that add value to what you are doing, and not just because you want to produce the world's most flexible design.