## Dispensables
### Comments (hiding poor code)
- Dispensables are things in the code that aren't needed or shouldn't be needed - highlighting what could be unnecessary, redundant or poorly written code
- Comment smells: when the only reason comments exist is to explain code that is unclear or poorly writtenL
```Python
# This function checks if the user is active and has paid
def check(u):
	return u.a -- 1 and u.p == 1
```
- Alternative is to make the code clearer:
```python
def is_active_and_paid(user):
	return user.is_active and user.has_paid
```
### Data Class
- A class that contains only fields (data) and getters/setters when it should have "business" logic too.
- Data classes can be OK in some circumstances, e.g. for Parameter Objects, Data Transfer Objects (DTOs)
- Sometimes, they are not OK, e.g. a Rectangle class that only stores width and height but the code to calculate the area is written *outside* the class somewhere else - signs of other classes doing too much / Feature Envy
- Use **Move Method** to bring the logic (like `calculate_area()`) into the Data Class itself so it becomes a "real" object
### Dead Code
- Code that is no longer relevant, e.g. due to changing requirements, but has been kept in the system or kept as commented-out code "just in case" it is needed again in the future.
```python
def calculate_total()
	# code here
	
def calculate_total_old()
	# code for older version here
	
def calculate_tax(order):
	# Old tax logic:
	# return order.total * 0.05
	return order.total * 0.07
```
- Problems: cognitive load (more code to interpret, where else is being used? what else has been left in that's not needed? are there still tests running for it?)
- The solution? Version control!
### Middle-Man
- A Middle-Man is a class that does nothing but delegate to another class in your code (or does too much of the latter)
```Java
class Person {
	String name;
	Department d;
	
	String getName() { return name; }
	
	String getDeptManager() {
		return d.getManager()
	}
	
	String getDeptTelephone() {
		return d.getTelephone();	
	}
	
	String getDeptID() {
		return d.getID();
	}
}

class Department {
	String manager;
	String telephone;
	String ID;
	
	// Get/Set methods for the above	
}

// Elsewhere in code:
Person p = new Person();
p.getName();
p.getDeptManager();
p.getDeptID();
etc..
```
- There may have been an intent behind this
- E.g. Doing this:
```Java
Person p = new Person();
p.getName();
p.getDeptManager();
p.getDeptID();
etc.
```
- May avoid a potential Message Chain / Law of Demeter situation like this:
```Java
Person p = new Person();
p.getName();
p.getDepartment().getManager().getName();
```
- But we may be taking things too far now, potential getting into Feature Envy
- *Refactoring Option:* Use **Remove Middle-Man** to remove the in-between responsibilities from the Person class
```Java
class Person {
	String namel
	Department d;
	
	String getName() { return name; }
	
	Department getDept() {
		return d;
	}
}

// Elsewhere in code:

Person p = new Person();
name = p.getName();

Department dept = p.getDept();
id = dept.getID();
tel = dept.getTelephone();
etc.
```
### Speculative Generality (see also [[1.2 - Principles of Clean Code#Keep It Simple, Stupid (KISS)|KISS]] and [[1.2 - Principles of Clean Code#You Aren't Going to Need it (YAGNI)|YAGNI]])
- Code that has been added "just in case" for future needs that never arrive, often manifesting as unnecessary abstractions / parent classes, and "hooks" for future features
- Smells:
	- You add an interface "just in case"
	- You create an abstract class with no subclasses yet
	- You add parameters to methods that are never used
	- You design for future features that may never come
- Thinking about the future extensibility is important BUT what is really necessary now?
- If you didn't add the feature now, how difficult is it really going to be for someone to add in the future?
- Don't introduce technical debt now if it can be easily "paid" by someone else later
#### Example
- You have a library system to lend books. It has a Book class:
```Java
class Book() {
	String title;
	String author;
	Date datePublished;
	int numberOfPages;
	bool onLoad;
}
```
- You are worried. What if the library expands in the future and allows people to borrow other things, e.g. Books, Devices, Equipment, Software MP3 files or devices, etc.
- You produce a solution that will future proof the system. Yay!
![[Pasted image 20260124170700.png]]
#### Other guidelines: Favour composition over inheritance
- Why?
	- Inheritance creates tight coupling and fragile hierarchies
	- Composition give you flexibility and clearer responsibilities
- Not a refactoring per se, but another design principle
- Example:
	- A car is not a type of Engine - the relationship is wrong.
	- If you can change how engines work, you risk breaking all subclasses
	- You can't easily swap engines (e.g. electric vs diesel)
```java
class Engine {
	void start() {
		System.out.println("Starting...");
	}
}

class Car extends Engine {
	void drive() {
		start(); // inhertited from Engine
		System.out.println("Driving...");
	}
}
```
- A Car *has an* Engine, **not** a Car *inherits from* Engine
```Java
class Engine {
	void start() {
		System.out.println("Engine starting...");
	}
}

class Car {
	private Engine engine;
	
	Car(Engine engine) {
		this.engine = engine;
	}
	
	void drive() {
		engine.start(); // delegate instead of inherit
		System.out.println("Car driving...");
	}
}
```
## Red-Green-Refactor
- Red-Green-Refactor is a strategy that can be used during test-driven-development (see later weeks on this)
- Because refactoring involves modifying existing code, how can we reassure ourselves that we don't break anything else or introduce new errors?
- This is where the existence of unit tests in legacy code is extremely valuable - you can immediately run regression tests to check existing code still works as expected
- In the context of new refactorings you can:
	- Red: Write failing tests for the changes you are about to make
	- Green: Write just enough code to make the tests pass (not full refactoring at this stage)
	- Refactor: Make the new code clean, gradually and incrementally, shifting between Green and Refactor where required